# Задание

- Дорофеев Николай Павлович Р33101
- `alg | acc | neum | hw | tick | struct | stream | port | pstr | prob1 | [4]char`
- Без усложнения

## Язык программирования

Пример:
```
  int x 10;
  str s Hello World!;
  new x = ( x + 1 ) / ( 3 - 2 );
  output_int(x);
  while( x > 0 );
  new x = x - 1;
  output_str(s);
  endWhile;
```
Сложная математика реализована самым банальным способом: транслятор раскладывает выражение на простейшие, результат записывается в первый элемент.
Алгоритм реализуется через память, поэтому проблемы с недостатком регистров не возникает.

### Описание

- ";" -> конец строчки кода
- два типа данных -> int и string
- global scope
- "=" -> вместе с ключевым словом new позволяет изменить значение переменной в памяти
- // - > комментарий, в конце также должна быть ;
- operands ::= "+" | "-" | "*" | "/" | "<" | ">" | "==" | "!=" | "<=" | ">="
- "while", "endWhile" -> цикл с предусловием (фигурных скобок как в Java нет, endWhile означает конец цикла)
- Ввод через встроенные функции input_int(x), input_str(x) -> ввод сразу пишется в переменную
- Вывод также через встроенные функции output_int(x), output_str(x) -> где x - переменная для вывода

### Ограничения 

Все ограничения связаны с упрощением написания транслятора:
- В while и new необходимо ставить проблемы между скобками и значениями
- while не поддерживает математику внутри условия, необходимо сделать ее предыдущей строчкой
- Размер int ограничен python: 2**63 - 1
- Размер str ограничен размером памяти, необходимо, чтобы все инструкции и значения записались.
  
  (Если мы имеем код: str s ...;),то макимальная длина будет размер памяти - 1 (первое число это длина строки по варианту)

### Описание по форме Бэкуса-Наура

```
<КОД> ::==  <Идентификатор> <Переменная> | <Пустро> <Арифметическое выражение> | <Сравнение> | <Пусто>
<Идентификатор> ::== <new> | <int> | <string> | <while(> | <endWhile> | <new> | <input_str(> | <input_int(> | <output_str(> | <output_int(> | <\\>
<Типы данных> ::== <int> | <string>
<Операнд> ::== <Число> | <Переменная>
<Операция арифметики> ::== <+> | <-> | <*> | </>
<Операция сравнения> ::== < < > | < > > | <==> | <!=> | < <= > | < >= >
<Арифметическое выражение> ::== <Арифметическое выражение> | <Операнд>  <Операция арифметики> <Арифметическое выражение> | <Число>
<Сравнение> ::== <Операция сравнения> <Операнд>
```

## Память

Машинное слово не определено(инструкции реализованы по варианту словарем, а память общая)
Размер памяти захардкожен и равен 1000. В конце есть зарезервированная ячейка для реализации вывода строк

Числа в памяти выглядят так, записываются начиная с конца

| Значение | Адрес    |
|:---------|:---------|
| 123      | 1000     | 
| 11       | 999      | 
| 0        | 998      | 
| 1        | 997      | 

Инструкции записываются с начала(с 0 адреса, PC также по умолчанию равен 0)

| Opcode | Адрес | Адрес    |
|:-------|:-------|:--------|
| Read   | 999   | 0        | 
| Read   | 998   | 1        | 
| Add    | 997   | 2        | 
| Write  | 998   | 3        |

Opcode и адрес объединяются в отдельный словарь, поэтому для памяти инструкции и числа выглядят одинаково:

({"value": object, "address": int}), где object:
- object = int -> значение числа
- object = {"value": opcode, "address": int} -> инструкция

## Инструкции

|Инструкция   | Кол-во тактов | Описание                                                    |
|:-------------|:--------------|:------------------------------------------------------------|
| add <addr>   | 2             | увеличить значение аккумулятора на число по адресу          |
| sub <addr>   | 2             | уменьшить значение аккумулятора на число по адресу          |
| mul <addr>   | 1             | умножить значение аккумулятора на число по адресу           |
| div <addr>   | 1             | разделить значение аккумулятора на число по адресу          |
| jump <addr>  | 2             | прыгнуть на + addr (в реализации просто PC += addr)         |
| jmpz         | 2             | условный переход acc == 0                                   |
| jmpnz        | 1             | условный переход acc != 0                                   |
| jmps         | 2             | условный переход acc < 0                                    |
| jmpsz        | 0             | условный переход acc <= 0                                   |
| jmpns        | 0             | условный переход acc >= 0                                   |
| jmpnsnz      | 0             | условный переход acc >  0                                   |
| read<addr>   | 0             | прочитать из памяти по адресу addr в акум                   |
| write<addr>  | 0             | записать в память по адресу addr из акума                   |
| readadr<addr>| 0             | записать значение адреса addr в акум                        |
| writeadr     | 0             | записать значение акума в регистр адреса и сразу прочитать из памяти по этому адресу в акум|
| input<flag>  | 0             | получить токен ввода в акум                                 |
| output<flag> | 0             | отправить значение акума как токен вывода                   |
| break        | 0             | остановка                                                   |

- Условный переход при выполненном условии джампит на +2, чтобы пропустить джамп, который идет следующей командой.
- Флаг в инструкциях ввода и вывода необходим из-за различного представления чисел и чаров:
- Если вводим или выводим int, flag = 0
- Если char, flag = 1

Все инструкции представлены в Enum-e [Opcode.py](opc.py)

## Транслятор

[Translator.py](translator.py)

Транслятор делает только один обход токенов(кода разделенного по ";") в основном методе translate

-Ввод: текстовый файл с кодом программы
-Вывод: текстовый файл с машинным кодом(переменные со стартовыми значениями и инструкции)

