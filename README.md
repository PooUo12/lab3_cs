# Задание

- Дорофеев Николай Павлович Р33101
- `alg | acc | neum | hw | tick | struct | stream | port | pstr | prob1 | [4]char`
- Без усложнения

## Язык программирования

Пример:
```
  int x 10;
  str s Hello World!;
  new x = ( x + 1 ) / ( 3 - 2 );
  output_int(x);
  while( x > 0 );
  new x = x - 1;
  output_str(s);
  endWhile;
```
Сложная математика реализована самым банальным способом: транслятор раскладывает выражение на простейшие, результат записывается в первый элемент.
Алгоритм реализуется через память, поэтому проблемы с недостатком регистров не возникает.

### Описание

- ";" -> конец строчки кода
- два типа данных -> int и string
- global scope
- "=" -> вместе с ключевым словом new позволяет изменить значение переменной в памяти
- // - > комментарий, в конце также должна быть ;
- operands ::= "+" | "-" | "*" | "/" | "<" | ">" | "==" | "!=" | "<=" | ">="
- "while", "endWhile" -> цикл с предусловием (фигурных скобок как в Java нет, endWhile означает конец цикла)
- Ввод через встроенные функции input_int(x), input_str(x) -> ввод сразу пишется в переменную
- Вывод также через встроенные функции output_int(x), output_str(x) -> где x - переменная для вывода

### Ограничения 

Все ограничения связаны с упрощением написания транслятора:
- В while и new необходимо ставить проблемы между скобками и значениями
- while не поддерживает математику внутри условия, необходимо сделать ее предыдущей строчкой
- Размер int ограничен python: 2**63 - 1
- Размер str ограничен размером памяти, необходимо, чтобы все инструкции и значения записались.
  
  (Если мы имеем код: str s ...;),то макимальная длина будет размер памяти - 1 (первое число это длина строки по варианту)

### Описание по форме Бэкуса-Наура

```
<КОД> ::==  <Идентификатор> <Переменная> | <Пустро> <Арифметическое выражение> | <Сравнение> | <Пусто>
<Идентификатор> ::== <new> | <int> | <string> | <while(> | <endWhile> | <new> | <input_str(> | <input_int(> | <output_str(> | <output_int(> | <\\>
<Типы данных> ::== <int> | <string>
<Операнд> ::== <Число> | <Переменная>
<Операция арифметики> ::== <+> | <-> | <*> | </>
<Операция сравнения> ::== < < > | < > > | <==> | <!=> | < <= > | < >= >
<Арифметическое выражение> ::== <Арифметическое выражение> | <Операнд>  <Операция арифметики> <Арифметическое выражение> | <Число>
<Сравнение> ::== <Операция сравнения> <Операнд>
```

## Память

Машинное слово не определено(инструкции реализованы по варианту словарем, а память общая)
Размер памяти захардкожен и равен 1000. В конце есть зарезервированная ячейка для реализации вывода строк

Числа в памяти выглядят так, записываются начиная с конца

| Значение | Адрес    |
|:---------|:---------|
| 123      | 1000     | 
| 11       | 999      | 
| 0        | 998      | 
| 1        | 997      | 

Инструкции записываются с начала(с 0 адреса, PC также по умолчанию равен 0)

| Opcode | Адрес | Адрес    |
|:-------|:-------|:--------|
| READ   | 999   | 0        | 
| Read   | 998   | 1        | 
| Add    | 997   | 2        | 
| Write  | 998   | 3        |

Opcode и адрес объединяются в отдельный словарь, поэтому для памяти инструкции и числа выглядят одинаково:
({"value": object, "address": int})



## Транслятор

[Translator.py](translator.py)

Транслятор делает только один обход токенов(кода разделенного по ";") в основном методе translate

-Ввод: текстовый файл с кодом программы
-Вывод: текстовый файл с машинным кодом(переменные со стартовыми значениями и инструкции)

